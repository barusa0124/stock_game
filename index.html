<!DOCTYPE html>
<html>
<head>
  <base target="_top">
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!-- Chart.jsライブラリのインポート -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  <!-- 時刻スケール用アダプターの追加 -->
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
  
  <!-- Tailwind CSSをCDNから手動インライン化 -->
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
  <title>株価情報</title>
  <style>
    /* Tailwind CSSクラスの手動再現とカスタムスタイル */
    :root {
        font-family: 'Inter', sans-serif;
        --color-bg: #f0f4f8; 
        --color-card-bg: #fff;
        --color-border: #e5e7eb;
        --color-text-primary: #1f2937;
        --color-text-secondary: #6b7280;
        --color-indigo: rgb(79, 70, 229);
        --color-green: rgb(22, 163, 74);
        --color-red: rgb(220, 38, 38);
    }
    body {
        font-family: var(--font-family);
        background-color: var(--color-bg);
        margin: 0; padding: 0.5rem 1rem;
    }
    .max-w-6xl { max-width: 1152px; }
    .mx-auto { margin-left: auto; margin-right: auto; }

    /* カードスタイル */
    .card { 
        background-color: var(--color-card-bg);
        border: 1px solid var(--color-border);
        border-radius: 0.75rem; 
        box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06); 
        padding: 1.5rem;
        transition: transform 0.2s;
    }
    .card:hover { transform: translateY(-2px); }

    /* タイポグラフィ */
    .text-center { text-align: center; }
    .text-3xl { font-size: 1.875rem; line-height: 2.25rem; }
    .font-extrabold { font-weight: 800; }
    .text-indigo-700 { color: rgb(67, 56, 202); }
    .text-sm { font-size: 0.875rem; line-height: 1.25rem; }
    .text-gray-500 { color: var(--color-text-secondary); }
    .text-xl { font-size: 1.25rem; line-height: 1.75rem; }
    .font-bold { font-weight: 700; }
    .text-gray-800 { color: var(--color-text-primary); }
    .mb-2 { margin-bottom: 0.5rem; }
    .mb-8 { margin-bottom: 2rem; }
    .border-b { border-bottom: 1px solid var(--color-border); }
    .pb-2 { padding-bottom: 0.5rem; }

    /* レイアウト（Grid/Flex） */
    .grid { display: grid; }
    .gap-6 { gap: 1.5rem; }
    .mb-8 { margin-bottom: 2rem; }
    .grid-cols-1 { grid-template-columns: repeat(1, minmax(0, 1fr)); }
    
    @media (min-width: 1024px) { /* lg */
        .lg\:grid-cols-3 { grid-template-columns: repeat(3, minmax(0, 1fr)); }
        .lg\:col-span-1 { grid-column: span 1 / span 1; }
        .lg\:col-span-2 { grid-column: span 2 / span 2; }
    }
    .space-y-4 > * + * { margin-top: 1rem; }

    /* 銘柄カード（均一化のためflexを使用） */
    #price-board {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); 
        gap: 1rem;
    }
    #price-board > div {
        display: flex;
        flex-direction: column;
        justify-content: center;
        padding: 1.25rem; 
        min-height: 120px; 
    }
    .price-details {
        display: flex;
        align-items: flex-end;
        justify-content: space-between;
        margin-bottom: 0.75rem;
    }
    .text-4xl { font-size: 2.25rem; line-height: 2.5rem; }
    .text-indigo-600 { color: var(--color-indigo); }
    .text-right { text-align: right; }
    .text-lg { font-size: 1.125rem; line-height: 1.75rem; }
    .text-green-600 { color: var(--color-green); }
    .text-red-600 { color: var(--color-red); }

    /* チャートコンテナと凡例 */
    .chart-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 1rem;
        border-bottom: 1px solid var(--color-border);
        padding-bottom: 0.5rem;
    }
    .chart-title-wrapper {
        display: flex;
        align-items: center;
        gap: 1rem;
    }
    .chart-container-wrapper { 
        display: flex;
        gap: 1rem; 
        height: 300px; 
    }
    .combined-chart-area {
        flex-grow: 1;
        max-width: calc(100% - 196px); 
        position: relative;
    }
    .chart-legend-wrapper {
        width: 25%;
        min-width: 180px;
        max-width: 180px;
        border-left: 1px solid var(--color-border);
        padding-left: 0.75rem;
        overflow-y: auto;
    }
    .legend-item {
        display: flex;
        align-items: center;
        font-size: 0.875rem;
        color: #4b5563; 
        margin-bottom: 4px;
        cursor: pointer;
        transition: opacity 0.2s, filter 0.2s;
    }
    /* 非表示時のスタイル強化 */
    .legend-item.inactive {
        opacity: 0.3; 
        filter: grayscale(100%);
        background-color: #fff;
    }
    .legend-item input[type="checkbox"] {
        margin-right: 0.5rem;
        height: 1rem; width: 1rem;
        border-radius: 0.25rem;
        cursor: pointer;
    }

    /* プルダウンメニュー */
    select {
        background-color: #fff;
        border: 1px solid var(--color-border);
        border-radius: 0.375rem;
        padding: 0.25rem 0.5rem;
        font-size: 0.875rem;
        color: var(--color-text-primary);
        cursor: pointer;
    }
    select:focus {
        outline: 2px solid var(--color-indigo);
        outline-offset: 1px;
    }

    /* 値上がり・値下がり色 */
    .text-green { color: var(--color-green); }
    .text-red { color: var(--color-red); }
    .bg-green-100 { background-color: #dcfce7; }
    .bg-red-100 { background-color: #fee2e2; }

    /* アニメーション */
    @keyframes flash-green {
        0% { background-color: #bbf7d0; }
        100% { background-color: transparent; }
    }
    @keyframes flash-red {
        0% { background-color: #fecaca; }
        100% { background-color: transparent; }
    }
    .flash-up { animation: flash-green 1s ease-out; }
    .flash-down { animation: flash-red 1s ease-out; }

    /* イベント履歴 */
    .event-history h2 {
        font-size: 1.125rem;
        font-weight: 700;
        margin-bottom: 0.75rem;
        border-bottom: 1px solid var(--color-border);
        padding-bottom: 0.5rem;
    }
    .event-list {
        list-style: none;
        padding: 0;
        margin: 0;
    }
    .event-item {
        padding-left: 0.75rem;
        border-left: 4px solid var(--color-indigo);
        margin-bottom: 0.75rem;
    }
    .event-title { font-weight: 600; color: var(--color-text-primary); font-size: 0.95rem; }
    .event-time { font-size: 0.75rem; color: var(--color-text-secondary); }

  </style>
</head>
<body class="p-4">
  <div class="max-w-6xl mx-auto">
    <header class="text-center mb-6">
      <h1 class="text-3xl font-extrabold text-indigo-700 mb-2">株価情報</h1>
      <p class="text-sm text-gray-500">
        最終読み込み時刻: <span id="last-updated" class="font-medium">--</span>
      </p>
    </header>
    
    <!-- チャートと凡例（株価情報）のエリア -->
    <div class="card">
        <div class="chart-header">
            <div class="chart-title-wrapper">
                <h2 class="text-xl font-bold text-gray-800">株価推移</h2>
                <select id="time-range-selector">
                    <!-- JSで生成 -->
                </select>
            </div>
        </div>
        
        <div class="chart-wrapper">
            <!-- グラフ本体 -->
            <div class="chart-canvas-container">
                <canvas id="combined-chart"></canvas>
                <div id="loading-message" class="flex justify-center items-center h-full text-gray-500">
                    データを読み込み中...
                </div>
            </div>
            
            <!-- 凡例と株価情報リスト -->
            <div class="chart-legend-container">
                <div class="flex justify-between items-center mb-2 sticky top-0 bg-white pb-2 border-b">
                    <h3 class="text-sm font-bold text-gray-700">銘柄・株価一覧</h3>
                    <span class="text-xs text-gray-400">クリックで表示切替</span>
                </div>
                <div id="legend-list" class="legend-list">
                    <!-- ここにJSでリストが生成されます -->
                </div>
            </div>
        </div>
    </div>
    
    <!-- イベント履歴 -->
    <div class="card event-history">
        <h2>直近のイベント履歴</h2>
        <ul id="event-list" class="event-list">
            <li class="text-gray-500 text-sm">イベントを待機中...</li>
        </ul>
    </div>

    <!-- 3. 株価表示エリア (銘柄別カード) -->
    <div class="lg:col-span-2 space-y-4">
       <h2 class="text-xl font-bold text-gray-800 mb-3 border-b pb-2">全銘柄の現在価格と変動</h2>
       <div id="price-board" class="grid grid-cols-1 md:grid-cols-2 gap-4">
         <div id="loading" class="col-span-1 md:col-span-2 text-center text-gray-500 py-10">
           データを読み込み中...
         </div>
       </div>
     </div>
  </div>

  <script>
    // IIFEで全体をラッピングし、スコープを隔離
    (function() {
      
      const UPDATE_INTERVAL = 5000; 
      const EVENT_HISTORY_COUNT = 3; 
      const LOCAL_STORAGE_KEY = 'active_stocks_v2'; 
      const JSON_FILE_URL = './stock_schedule.json';

      const TIME_RANGE_OPTIONS = [
          { label: '直近 5分', value: 5 },
          { label: '直近 10分', value: 10 },
          { label: '直近 30分', value: 30 }
      ];
      let currentHistoryMinutes = 10; 

      let pricesSchedule = []; 
      let eventsSchedule = []; 
      let ACTIVE_STOCKS = new Set(); 
      let stockChart = null; 
      let dynamicStockColors = {}; 

      const COLOR_PALETTE = [
          "rgb(59, 130, 246)", "rgb(16, 185, 129)", "rgb(239, 68, 68)", 
          "rgb(245, 158, 11)", "rgb(99, 102, 241)", "rgb(132, 204, 22)", 
          "rgb(249, 115, 22)", "rgb(168, 85, 247)", "rgb(236, 72, 153)", "rgb(6, 182, 212)"
      ];
      
      // --- UTILITY FUNCTIONS ---

      function getColorForStock(name) {
          if (dynamicStockColors[name]) return dynamicStockColors[name];
          const index = Object.keys(dynamicStockColors).length;
          const color = COLOR_PALETTE[index % COLOR_PALETTE.length];
          dynamicStockColors[name] = color;
          return color;
      }

      function getYAxisScale(minPrice, maxPrice) {
          if (minPrice >= maxPrice) { 
              const center = minPrice || 1000; 
              const interval = Math.max(100, Math.floor(center * 0.05));
              return { scaleMin: center - interval, scaleMax: center + interval };
          }
          const range = maxPrice - minPrice;
          const roughInterval = range / 4;
          const magnitude = Math.pow(10, Math.floor(Math.log10(roughInterval)));
          let interval;
          const normalized = roughInterval / magnitude;
          if (normalized <= 1.5) interval = 1 * magnitude;
          else if (normalized <= 3.5) interval = 2 * magnitude;
          else if (normalized <= 7.5) interval = 5 * magnitude;
          else interval = 10 * magnitude;
          return { scaleMin: Math.floor(minPrice / interval) * interval, scaleMax: Math.ceil(maxPrice / interval) * interval };
      }

      // --- Chart.js 関連 ---

      function initializeChart(chartData, scaleMin, scaleMax, chartRangeMs) {
          const ctx = document.getElementById('combined-chart').getContext('2d');
          
          if (stockChart) {
              stockChart.data.datasets = chartData.datasets;
              stockChart.options.scales.y.min = scaleMin;
              stockChart.options.scales.y.max = scaleMax;
              stockChart.options.scales.x.min = Date.now() - chartRangeMs;
              stockChart.options.scales.x.max = Date.now();
              stockChart.update('none');
              return;
          }

          stockChart = new Chart(ctx, {
              type: 'line',
              data: chartData,
              options: {
                  responsive: true,
                  maintainAspectRatio: false,
                  animation: { duration: 0 },
                  plugins: {
                      legend: { display: false }, 
                      tooltip: { 
                          mode: 'index', 
                          intersect: false,
                          bodyFont: { size: 13 }
                      }
                  },
                  layout: { padding: { left: 0, right: 10, top: 10, bottom: 0 } },
                  scales: {
                      x: {
                          type: 'time',
                          time: {
                              unit: 'minute',
                              displayFormats: { minute: 'H:mm' }
                          },
                          min: Date.now() - chartRangeMs,
                          max: Date.now(),
                          ticks: { source: 'auto', maxTicksLimit: 6 },
                          grid: { display: false }
                      },
                      y: {
                          min: scaleMin,
                          max: scaleMax,
                          position: 'right', 
                          ticks: {
                              callback: (value) => value.toLocaleString(),
                              maxTicksLimit: 6
                          }
                      }
                  }
              }
          });
      }

      function updateChartData(pricesSchedule) {
          const now = Date.now();
          const historyMs = currentHistoryMinutes * 60 * 1000;
          
          const filteredHistory = pricesSchedule.filter(entry => 
              entry.time_date.getTime() >= (now - historyMs) && entry.time_date.getTime() <= now
          );

          if (filteredHistory.length === 0) return;

          let activePrices = filteredHistory.flatMap(entry => entry.prices
              .filter(p => ACTIVE_STOCKS.has(p.name))
              .map(p => p.price)
          );
          
          let minPrice = 0, maxPrice = 100;
          if (activePrices.length > 0) {
              minPrice = Math.min(...activePrices);
              maxPrice = Math.max(...activePrices);
          } else {
             let allPrices = filteredHistory.flatMap(entry => entry.prices.map(p => p.price));
             if(allPrices.length > 0) {
                 minPrice = Math.min(...allPrices);
                 maxPrice = Math.max(...allPrices);
             }
          }

          const { scaleMin, scaleMax } = getYAxisScale(minPrice, maxPrice);

          const stockNames = pricesSchedule.length > 0 ? pricesSchedule[0].prices.map(p => p.name) : [];
          const datasets = stockNames.map(name => {
              const dataPoints = filteredHistory.map(entry => {
                  const priceEntry = entry.prices.find(p => p.name === name);
                  return {
                      x: entry.time_date.getTime(),
                      y: priceEntry ? priceEntry.price : null 
                  };
              });

              const color = getColorForStock(name); 

              return {
                  label: name,
                  data: dataPoints,
                  borderColor: color,
                  backgroundColor: color,
                  borderWidth: 2,
                  pointRadius: 0, 
                  pointHoverRadius: 4,
                  fill: false,
                  tension: 0.1,
                  hidden: !ACTIVE_STOCKS.has(name) 
              };
          });

          initializeChart({ datasets }, scaleMin, scaleMax, historyMs);
      }

      // --- 凡例・リスト表示関連 ---

      function updateLegendList(currentPrices, previousPrices) {
          const listContainer = document.getElementById('legend-list');
          
          if (listContainer.children.length !== currentPrices.length) {
              listContainer.innerHTML = '';
              currentPrices.forEach(item => {
                  const name = item.name;
                  const color = getColorForStock(name);
                  
                  const div = document.createElement('div');
                  div.className = `legend-item ${ACTIVE_STOCKS.has(name) ? '' : 'inactive'}`;
                  div.id = `legend-item-${name}`;
                  div.onclick = () => toggleStock(name);
                  
                  div.innerHTML = `
                      <div class="legend-left">
                          <span class="legend-color" style="background-color: ${color};"></span>
                          <span class="legend-name">${name}</span>
                      </div>
                      <div class="legend-right">
                          <div class="legend-price" id="legend-price-${name}">--</div>
                          <div class="legend-change" id="legend-change-${name}">--</div>
                      </div>
                  `;
                  listContainer.appendChild(div);
              });
          }

          currentPrices.forEach(item => {
              const name = item.name;
              const priceEl = document.getElementById(`legend-price-${name}`);
              const changeEl = document.getElementById(`legend-change-${name}`);
              const itemEl = document.getElementById(`legend-item-${name}`);
              
              if (!priceEl) return;

              const currentPriceStr = `¥${item.price.toLocaleString()}`;
              if (priceEl.textContent !== currentPriceStr) {
                  priceEl.textContent = currentPriceStr;
                  const prevPriceVal = previousPrices ? (previousPrices.find(p => p.name === name)?.price || item.price) : item.price;
                  if (item.price > prevPriceVal) itemEl.classList.add('flash-up');
                  else if (item.price < prevPriceVal) itemEl.classList.add('flash-down');
                  
                  setTimeout(() => itemEl.classList.remove('flash-up', 'flash-down'), 1000);
              }

              let prevPrice = previousPrices ? previousPrices.find(p => p.name === name)?.price : item.price;
              if (!prevPrice) prevPrice = item.price;
              
              const diff = item.price - prevPrice;
              const ratio = prevPrice !== 0 ? (diff / prevPrice * 100).toFixed(2) : "0.00";
              const sign = diff > 0 ? "+" : "";
              
              changeEl.textContent = `${sign}${diff} (${sign}${ratio}%)`;
              changeEl.className = "legend-change"; 
              if (diff > 0) changeEl.classList.add("text-green");
              else if (diff < 0) changeEl.classList.add("text-red");
              else changeEl.classList.add("text-gray");
          });
      }

      function toggleStock(name) {
          if (ACTIVE_STOCKS.has(name)) {
              ACTIVE_STOCKS.delete(name);
          } else {
              ACTIVE_STOCKS.add(name);
          }
          saveActiveStocks(ACTIVE_STOCKS);
          
          const itemEl = document.getElementById(`legend-item-${name}`);
          if (itemEl) {
              if (ACTIVE_STOCKS.has(name)) itemEl.classList.remove('inactive');
              else itemEl.classList.add('inactive');
          }

          if (stockChart) {
              const datasetIndex = stockChart.data.datasets.findIndex(ds => ds.label === name);
              if (datasetIndex > -1) {
                  stockChart.data.datasets[datasetIndex].hidden = !ACTIVE_STOCKS.has(name);
              }
          }
          updateChartData(pricesSchedule); 
      }

      function updateEventHistory(events) {
          const list = document.getElementById('event-list');
          list.innerHTML = '';
          
          if (events.length === 0) {
              list.innerHTML = '<li class="text-gray-500 text-sm">イベント待機中...</li>';
              return;
          }
          
          events.slice(0, EVENT_HISTORY_COUNT).forEach(event => {
              const time = event.time_date.toLocaleTimeString('ja-JP', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
              const li = document.createElement('li');
              li.className = 'event-item';
              li.innerHTML = `
                  <div class="event-title">${event.event_title}</div>
                  <div class="event-time">${time} 発生</div>
              `;
              list.appendChild(li);
          });
      }

      // 2. 下部のカード更新 (IDの重複を解消: card- プレフィックスを使用)
      function updatePriceCards(currentPrices, previousPrices) {
        const board = document.getElementById('price-board');
        if (!board.children.length) board.innerHTML = '';

        currentPrices.forEach(item => {
          const safeName = item.name.replace(/[^a-zA-Z0-9\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF]/g, ''); 
          const cardId = `card-${safeName}`; // 凡例(price-)と被らないように変更
          
          let existingElement = document.getElementById(cardId);
          let prevPrice = previousPrices ? previousPrices.find(p => p.name === item.name)?.price : item.price;
          if(!prevPrice) prevPrice = item.price;
          
          const changeAmount = item.price - prevPrice;
          const changeRatio = prevPrice > 0 ? (changeAmount / prevPrice) * 100 : 0;
          const sign = changeAmount >= 0 ? '▲' : '▼';
          const colorClass = changeAmount >= 0 ? 'text-green' : 'text-red';

          if (!existingElement) {
              const newDiv = document.createElement('div');
              newDiv.id = cardId;
              newDiv.className = "stock-card";
              newDiv.innerHTML = `
                  <div class="stock-name">${item.name}</div>
                  <div class="stock-values">
                    <span class="stock-price">¥ ${item.price.toLocaleString()}</span>
                    <div class="stock-change-group">
                        <div class="stock-diff ${colorClass}">${sign} ${changeAmount.toLocaleString()}</div>
                        <div class="stock-ratio ${colorClass}">(${changeRatio.toFixed(2)}%)</div>
                    </div>
                  </div>
              `;
              board.appendChild(newDiv);
          } else {
              const priceSpan = existingElement.querySelector('.stock-price');
              const diffDiv = existingElement.querySelector('.stock-diff');
              const ratioDiv = existingElement.querySelector('.stock-ratio');
              
              if (priceSpan.textContent !== `¥ ${item.price.toLocaleString()}`) {
                  priceSpan.textContent = `¥ ${item.price.toLocaleString()}`;
                  existingElement.classList.add(changeAmount >= 0 ? 'flash-up' : 'flash-down');
                  setTimeout(() => existingElement.classList.remove('flash-up', 'flash-down'), 1000);
              }
              
              diffDiv.className = `stock-diff ${colorClass}`;
              diffDiv.textContent = `${sign} ${changeAmount.toLocaleString()}`;
              ratioDiv.className = `stock-ratio ${colorClass}`;
              ratioDiv.textContent = `(${changeRatio.toFixed(2)}%)`;
          }
        });
      }

      // --- データロードとメインループ ---
      
      function initTimeRangeSelector() {
          const select = document.getElementById('time-range-selector');
          select.innerHTML = '';
          
          TIME_RANGE_OPTIONS.forEach(opt => {
              const option = document.createElement('option');
              option.value = opt.value;
              option.textContent = opt.label;
              if (opt.value === currentHistoryMinutes) option.selected = true;
              select.appendChild(option);
          });
          
          select.addEventListener('change', (e) => {
              currentHistoryMinutes = parseInt(e.target.value, 10);
              updateChartData(pricesSchedule); 
          });
      }

      function loadActiveStocks(allStockNames) {
          const stored = localStorage.getItem(LOCAL_STORAGE_KEY);
          if (stored) {
              try {
                  const arr = JSON.parse(stored);
                  if (Array.isArray(arr)) {
                      ACTIVE_STOCKS = new Set(arr);
                      return;
                  }
              } catch (e) { console.error(e); }
          }
          allStockNames.forEach(n => ACTIVE_STOCKS.add(n));
      }

      function saveActiveStocks(set) {
          try {
              localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(Array.from(set)));
          } catch(e) {}
      }

      // ★★★ 修正: キャッシュバスティングを追加 ★★★
      async function loadSchedule() {
          const loadingMsg = document.getElementById('loading-message');
          try {
              // URLの末尾にタイムスタンプを追加してキャッシュを回避
              const cacheBuster = `?t=${new Date().getTime()}`;
              const res = await fetch(JSON_FILE_URL + cacheBuster);
              if (!res.ok) throw new Error(res.statusText);
              const data = await res.json();

              if (!data || !data[0] || !data[0].prices_schedule) throw new Error("Invalid JSON format");

              pricesSchedule = data[0].prices_schedule;
              eventsSchedule = data[0].events_schedule;

              [pricesSchedule, eventsSchedule].forEach(arr => {
                  arr.forEach(d => d.time_date = new Date(d.time_absolute_iso));
                  arr.sort((a, b) => a.time_date - b.time_date);
              });

              if (loadingMsg) loadingMsg.remove();
              
              const allNames = pricesSchedule.length > 0 ? pricesSchedule[0].prices.map(p => p.name) : [];
              
              loadActiveStocks(allNames);
              initTimeRangeSelector();
              drawLegend(allNames); 

              checkAndUpdate();
              setInterval(checkAndUpdate, UPDATE_INTERVAL);

          } catch (e) {
              if (loadingMsg) {
                  loadingMsg.textContent = "データ読み込みエラー";
                  loadingMsg.classList.add("text-red");
              }
              console.error(e);
          }
      }

      function checkAndUpdate() {
          if (pricesSchedule.length === 0) return;
          const now = new Date();
          
          let latestPriceData = null;
          let previousPriceData = null;
          
          for (let i = 0; i < pricesSchedule.length; i++) {
              const entry = pricesSchedule[i];
              if (entry.time_date <= now) {
                  previousPriceData = latestPriceData; 
                  latestPriceData = entry.prices;
              } else {
                  break;
              }
          }

          const recentEvents = eventsSchedule.filter(e => e.time_date <= now).reverse();

          if (latestPriceData) {
              updateLegendList(latestPriceData, previousPriceData);
              updateEventHistory(recentEvents);
              updateChartData(pricesSchedule);
              updatePriceCards(latestPriceData, previousPriceData); 
              document.getElementById('last-updated').textContent = new Date().toLocaleTimeString('ja-JP');
          } else {
              const loadingMsg = document.getElementById('loading-message');
              if(loadingMsg) {
                  loadingMsg.style.display = 'flex';
                  loadingMsg.textContent = "ゲーム開始前です";
              }
              document.getElementById('price-board').innerHTML = '<div class="col-span-1 md:col-span-2 text-center text-gray-500 py-10">ゲーム開始時刻までお待ちください。</div>';
          }
      }
      
      // スタート
      loadSchedule();

    })();
  </script>
</body>
</html>
