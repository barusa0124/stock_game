<!DOCTYPE html>
<html>
<head>
  <base target="_top">
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!-- Chart.jsライブラリのインポート -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  <!-- 時刻スケール用アダプターの追加 -->
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
  
  <!-- Tailwind CSSをCDNから手動インライン化 -->
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
  <title>株価情報</title>
  <style>
    /* Tailwind CSSクラスの手動再現とカスタムスタイル */
    :root {
        font-family: 'Inter', sans-serif;
        --color-bg: #f0f4f8; 
        --color-card-bg: #fff;
        --color-border: #e5e7eb;
        --color-text-primary: #1f2937;
        --color-text-secondary: #6b7280;
        --color-indigo: rgb(79, 70, 229);
        --color-green: rgb(22, 163, 74);
        --color-red: rgb(220, 38, 38);
    }
    body {
        font-family: var(--font-family);
        background-color: var(--color-bg);
        margin: 0; padding: 0.5rem;
    }
    .max-w-6xl { max-width: 1152px; }
    .mx-auto { margin-left: auto; margin-right: auto; }

    /* カードスタイル */
    .card { 
        background-color: var(--color-card-bg);
        border: 1px solid var(--color-border);
        border-radius: 0.75rem; 
        box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06); 
        padding: 1rem;
        margin-bottom: 1.5rem;
    }

    /* ヘッダー */
    .text-center { text-align: center; }
    .text-3xl { font-size: 1.5rem; line-height: 2rem; }
    .font-extrabold { font-weight: 800; }
    .text-indigo-700 { color: rgb(67, 56, 202); }
    .text-sm { font-size: 0.875rem; }
    .text-gray-500 { color: var(--color-text-secondary); }
    .mb-6 { margin-bottom: 1.5rem; }

    /* --- チャートエリアのレスポンシブレイアウト --- */
    .chart-wrapper {
        display: flex;
        flex-direction: column; /* デフォルト（スマホ）は縦並び */
        gap: 1rem;
    }
    
    /* PCなどの大画面用レイアウト */
    @media (min-width: 768px) {
        .chart-wrapper {
            flex-direction: row; /* 横並び */
            height: 500px; /* PCでは高さを固定してスクロールさせる */
        }
        .chart-canvas-container {
            flex: 1; /* 残りの幅を埋める */
            height: 100%;
            min-width: 0; /* Flexbox内でのCanvas縮小対策 */
        }
        .chart-legend-container {
            width: 320px; /* 凡例の幅を固定 */
            min-width: 320px;
            border-left: 1px solid var(--color-border);
            padding-left: 1rem;
            overflow-y: auto; /* 縦スクロール有効化 */
            height: 100%;
        }
        .text-3xl { font-size: 1.875rem; line-height: 2.25rem; }
    }

    /* スマホ用調整 */
    @media (max-width: 767px) {
        .chart-canvas-container {
            height: 300px; /* スマホでのグラフの高さ */
            width: 100%;
        }
        .chart-legend-container {
            width: 100%;
            border-top: 1px solid var(--color-border);
            padding-top: 1rem;
            max-height: 400px;
            overflow-y: auto;
        }
    }

    /* 凡例アイテムのデザイン */
    .legend-list {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
    }
    .legend-item {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 0.5rem;
        border-radius: 0.5rem;
        background-color: #f9fafb;
        border: 1px solid transparent;
        cursor: pointer;
        transition: all 0.2s;
    }
    .legend-item:hover {
        background-color: #f3f4f6;
        border-color: #d1d5db;
    }
    .legend-item.inactive {
        opacity: 0.3; 
        filter: grayscale(100%);
        background-color: #fff;
    }
    
    .legend-left {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        flex: 1;
        min-width: 0; /* テキスト省略のため */
    }
    .legend-color {
        width: 12px;
        height: 12px;
        border-radius: 50%;
        flex-shrink: 0;
    }
    .legend-name {
        font-weight: 600;
        font-size: 0.9rem;
        color: var(--color-text-primary);
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }
    
    .legend-right {
        text-align: right;
        flex-shrink: 0;
    }
    .legend-price {
        font-weight: 700;
        font-size: 1rem;
        color: var(--color-text-primary);
    }
    .legend-change {
        font-size: 0.75rem;
        font-weight: 600;
    }

    /* チェックボックス（非表示にしてラベル全体をクリック可能にする） */
    .hidden-checkbox {
        display: none;
    }
    
    /* プルダウンメニュー */
    select {
        background-color: #fff;
        border: 1px solid var(--color-border);
        border-radius: 0.375rem;
        padding: 0.25rem 0.5rem;
        font-size: 0.875rem;
        color: var(--color-text-primary);
        cursor: pointer;
    }

    /* 値上がり・値下がり色 */
    .text-green { color: var(--color-green); }
    .text-red { color: var(--color-red); }
    .bg-green-100 { background-color: #dcfce7; }
    .bg-red-100 { background-color: #fee2e2; }

    /* アニメーション */
    @keyframes flash-green { 0% { background-color: #bbf7d0; } 100% { background-color: transparent; } }
    @keyframes flash-red { 0% { background-color: #fecaca; } 100% { background-color: transparent; } }
    /* ★★★ イベント強調用アニメーション (黄色) ★★★ */
    @keyframes flash-yellow { 0% { background-color: #fef08a; } 100% { background-color: transparent; } }
    
    .flash-up { animation: flash-green 1s ease-out; }
    .flash-down { animation: flash-red 1s ease-out; }
    .flash-highlight { animation: flash-yellow 2s ease-out; } /* 新規イベント用 */

    /* イベント履歴 */
    .event-history h2 {
        font-size: 1.125rem;
        font-weight: 700;
        margin-bottom: 0.75rem;
        border-bottom: 1px solid var(--color-border);
        padding-bottom: 0.5rem;
    }
    .event-list {
        list-style: none;
        padding: 0;
        margin: 0;
    }
    .event-item {
        padding-left: 0.75rem;
        border-left: 4px solid var(--color-indigo);
        margin-bottom: 0.75rem;
        padding: 0.5rem 0.75rem; /* アニメーションが見やすいようにパディング調整 */
        border-radius: 0 0.5rem 0.5rem 0; /* 右側だけ角丸 */
    }
    .event-title { font-weight: 600; color: var(--color-text-primary); font-size: 0.95rem; }
    .event-time { font-size: 0.75rem; color: var(--color-text-secondary); }

  </style>
</head>
<body class="p-4">
  <div class="max-w-6xl mx-auto">
    <header class="text-center mb-6">
      <h1 class="text-3xl font-extrabold text-indigo-700 mb-2">株価情報</h1>
      <p class="text-sm text-gray-500">
        最終読み込み時刻: <span id="last-updated" class="font-medium">--</span>
      </p>
    </header>
    
    <!-- チャートと凡例（株価情報）のエリア -->
    <div class="card">
        <div class="chart-header">
            <div class="flex items-center gap-4">
                <h2 class="text-xl font-bold text-gray-800">株価推移</h2>
                <select id="time-range-selector">
                    <!-- JSで生成 -->
                </select>
            </div>
        </div>
        <div class="chart-wrapper">
            <!-- グラフ本体 -->
            <div class="chart-canvas-container">
                <canvas id="combined-chart"></canvas>
                <div id="loading-message" class="flex justify-center items-center h-full text-gray-500">
                    データを読み込み中...
                </div>
            </div>
            
            <!-- 凡例と株価情報リスト -->
            <div class="chart-legend-container">
                <div class="flex justify-between items-center mb-2 sticky top-0 bg-white pb-2 border-b">
                    <h3 class="text-sm font-bold text-gray-700">銘柄・株価一覧</h3>
                    <span class="text-xs text-gray-400">クリックで表示切替</span>
                </div>
                <div id="legend-list" class="legend-list">
                    <!-- ここにJSでリストが生成されます -->
                </div>
            </div>
        </div>
    </div>
    
    <!-- イベント履歴 -->
    <div class="card event-history">
        <h2>イベント履歴</h2>
        <ul id="event-list" class="event-list">
            <li class="text-gray-500 text-sm">イベントを待機中...</li>
        </ul>
    </div>
    
  </div>

  <script>
    // IIFEで全体をラッピングし、スコープを隔離
    (function() {
      
      const UPDATE_INTERVAL = 5000; 
      const EVENT_HISTORY_COUNT = 3; 
      const LOCAL_STORAGE_KEY = 'active_stocks_v2'; 
      const JSON_FILE_URL = './stock_schedule.json';

      const TIME_RANGE_OPTIONS = [
          { label: '5分', value: 5 },
          { label: '10分', value: 10 },
          { label: '30分', value: 30 },
          { label: '1時間', value: 60 },
      ];
      let currentHistoryMinutes = 10; 

      let pricesSchedule = []; 
      let eventsSchedule = []; 
      let ACTIVE_STOCKS = new Set(); 
      let stockChart = null; 
      let dynamicStockColors = {}; 

      const COLOR_PALETTE = [
          "rgb(59, 130, 246)",   // Blue
          "rgb(16, 185, 129)",   // Green
          "rgb(239, 68, 68)",    // Red
          "rgb(245, 158, 11)",   // Amber
          "rgb(99, 102, 241)",   // Indigo
          "rgb(132, 204, 22)",   // Lime
          "rgb(249, 115, 22)",   // Orange
          "rgb(168, 85, 247)",   // Purple
          "rgb(236, 72, 153)",   // Pink
          "rgb(6, 182, 212)",    // Cyan
      ];
      
      // --- UTILITY FUNCTIONS ---

      function getColorForStock(name) {
          if (dynamicStockColors[name]) {
              return dynamicStockColors[name];
          }
          const index = Object.keys(dynamicStockColors).length;
          const color = COLOR_PALETTE[index % COLOR_PALETTE.length];
          dynamicStockColors[name] = color;
          return color;
      }

      function getYAxisScale(minPrice, maxPrice) {
          if (minPrice >= maxPrice) { 
              const center = minPrice || 1000; 
              const interval = Math.max(100, Math.floor(center * 0.05));
              return { scaleMin: center - interval, scaleMax: center + interval };
          }
          
          const range = maxPrice - minPrice;
          const roughInterval = range / 4;
          const magnitude = Math.pow(10, Math.floor(Math.log10(roughInterval)));
          let interval;
          
          const normalized = roughInterval / magnitude;
          if (normalized <= 1.5) interval = 1 * magnitude;
          else if (normalized <= 3.5) interval = 2 * magnitude;
          else if (normalized <= 7.5) interval = 5 * magnitude;
          else interval = 10 * magnitude;
          
          const scaleMin = Math.floor(minPrice / interval) * interval;
          const scaleMax = Math.ceil(maxPrice / interval) * interval;
          
          return { scaleMin, scaleMax };
      }

      // --- Chart.js 関連 ---

      function initializeChart(chartData, scaleMin, scaleMax, chartRangeMs) {
          const ctx = document.getElementById('combined-chart').getContext('2d');
          
          if (stockChart) {
              stockChart.data.datasets = chartData.datasets;
              stockChart.options.scales.y.min = scaleMin;
              stockChart.options.scales.y.max = scaleMax;
              stockChart.options.scales.x.min = Date.now() - chartRangeMs;
              stockChart.options.scales.x.max = Date.now();
              stockChart.update('none');
              return;
          }

          stockChart = new Chart(ctx, {
              type: 'line',
              data: chartData,
              options: {
                  responsive: true,
                  maintainAspectRatio: false,
                  animation: { duration: 0 },
                  plugins: {
                      legend: { display: false }, 
                      tooltip: { 
                          mode: 'index', 
                          intersect: false,
                          bodyFont: { size: 13 }
                      }
                  },
                  layout: { padding: { left: 0, right: 10, top: 10, bottom: 0 } },
                  scales: {
                      x: {
                          type: 'time',
                          time: {
                              unit: 'minute',
                              displayFormats: { minute: 'H:mm' }
                          },
                          min: Date.now() - chartRangeMs,
                          max: Date.now(),
                          ticks: { source: 'auto', maxTicksLimit: 6 },
                          grid: { display: false }
                      },
                      y: {
                          min: scaleMin,
                          max: scaleMax,
                          position: 'right', 
                          ticks: {
                              callback: (value) => value.toLocaleString(),
                              maxTicksLimit: 6
                          }
                      }
                  }
              }
          });
      }

      function updateChartData(pricesSchedule) {
          const now = Date.now();
          const historyMs = currentHistoryMinutes * 60 * 1000;
          
          const filteredHistory = pricesSchedule.filter(entry => 
              entry.time_date.getTime() >= (now - historyMs) && entry.time_date.getTime() <= now
          );

          if (filteredHistory.length === 0) return;

          let activePrices = filteredHistory.flatMap(entry => entry.prices
              .filter(p => ACTIVE_STOCKS.has(p.name))
              .map(p => p.price)
          );
          
          let minPrice = 0, maxPrice = 100;
          if (activePrices.length > 0) {
              minPrice = Math.min(...activePrices);
              maxPrice = Math.max(...activePrices);
          } else {
             let allPrices = filteredHistory.flatMap(entry => entry.prices.map(p => p.price));
             if(allPrices.length > 0) {
                 minPrice = Math.min(...allPrices);
                 maxPrice = Math.max(...allPrices);
             }
          }

          const { scaleMin, scaleMax } = getYAxisScale(minPrice, maxPrice);

          const stockNames = pricesSchedule.length > 0 ? pricesSchedule[0].prices.map(p => p.name) : [];
          const datasets = stockNames.map(name => {
              const dataPoints = filteredHistory.map(entry => {
                  const priceEntry = entry.prices.find(p => p.name === name);
                  return {
                      x: entry.time_date.getTime(),
                      y: priceEntry ? priceEntry.price : null 
                  };
              });

              const color = getColorForStock(name); 

              return {
                  label: name,
                  data: dataPoints,
                  borderColor: color,
                  backgroundColor: color,
                  borderWidth: 2,
                  pointRadius: 0, 
                  pointHoverRadius: 4,
                  fill: false,
                  tension: 0.1,
                  hidden: !ACTIVE_STOCKS.has(name) 
              };
          });

          initializeChart({ datasets }, scaleMin, scaleMax, historyMs);
      }

      // --- 凡例・リスト表示関連 ---

      function updateLegendList(currentPrices, previousPrices) {
          const listContainer = document.getElementById('legend-list');
          
          if (listContainer.children.length !== currentPrices.length) {
              listContainer.innerHTML = '';
              currentPrices.forEach(item => {
                  const name = item.name;
                  const color = getColorForStock(name);
                  
                  const div = document.createElement('div');
                  div.className = `legend-item ${ACTIVE_STOCKS.has(name) ? '' : 'inactive'}`;
                  div.id = `legend-item-${name}`;
                  div.onclick = () => toggleStock(name);
                  
                  div.innerHTML = `
                      <div class="legend-left">
                          <span class="legend-color" style="background-color: ${color};"></span>
                          <span class="legend-name">${name}</span>
                      </div>
                      <div class="legend-right">
                          <div class="legend-price" id="price-${name}">--</div>
                          <div class="legend-change" id="change-${name}">--</div>
                      </div>
                  `;
                  listContainer.appendChild(div);
              });
          }

          currentPrices.forEach(item => {
              const name = item.name;
              const priceEl = document.getElementById(`price-${name}`);
              const changeEl = document.getElementById(`change-${name}`);
              const itemEl = document.getElementById(`legend-item-${name}`);
              
              if (!priceEl) return;

              const currentPriceStr = `¥${item.price.toLocaleString()}`;
              if (priceEl.textContent !== currentPriceStr) {
                  priceEl.textContent = currentPriceStr;
                  const prevPriceVal = previousPrices ? (previousPrices.find(p => p.name === name)?.price || item.price) : item.price;
                  if (item.price > prevPriceVal) itemEl.classList.add('flash-up');
                  else if (item.price < prevPriceVal) itemEl.classList.add('flash-down');
                  
                  setTimeout(() => itemEl.classList.remove('flash-up', 'flash-down'), 1000);
              }

              let prevPrice = previousPrices ? previousPrices.find(p => p.name === name)?.price : item.price;
              if (!prevPrice) prevPrice = item.price;
              
              const diff = item.price - prevPrice;
              const ratio = prevPrice !== 0 ? (diff / prevPrice * 100).toFixed(2) : "0.00";
              const sign = diff > 0 ? "+" : "";
              
              changeEl.textContent = `${sign}${diff} (${sign}${ratio}%)`;
              changeEl.className = "legend-change"; 
              if (diff > 0) changeEl.classList.add("text-green");
              else if (diff < 0) changeEl.classList.add("text-red");
              else changeEl.classList.add("text-gray");
          });
      }

      function toggleStock(name) {
          if (ACTIVE_STOCKS.has(name)) {
              ACTIVE_STOCKS.delete(name);
          } else {
              ACTIVE_STOCKS.add(name);
          }
          saveActiveStocks(ACTIVE_STOCKS);
          
          const itemEl = document.getElementById(`legend-item-${name}`);
          if (itemEl) {
              if (ACTIVE_STOCKS.has(name)) itemEl.classList.remove('inactive');
              else itemEl.classList.add('inactive');
          }

          if (stockChart) {
              const datasetIndex = stockChart.data.datasets.findIndex(ds => ds.label === name);
              if (datasetIndex > -1) {
                  stockChart.data.datasets[datasetIndex].hidden = !ACTIVE_STOCKS.has(name);
              }
          }
          updateChartData(pricesSchedule); 
      }

      // ★★★ 修正点4: イベント履歴の差分更新と強調表示 ★★★
      function updateEventHistory(events) {
          const list = document.getElementById('event-list');
          
          if (events.length === 0) {
              list.innerHTML = '<li class="text-gray-500 text-sm">イベント待機中...</li>';
              return;
          }
          
          // "イベント待機中..." があれば消す
          const placeholder = list.querySelector('li.text-gray-500');
          if (placeholder) placeholder.remove();

          // 表示する最新N件
          const displayEvents = events.slice(0, EVENT_HISTORY_COUNT);
          const displayEventIds = new Set(displayEvents.map(e => e.time_absolute_iso));

          // 1. 不要な古いイベントを削除
          Array.from(list.children).forEach(li => {
              if (li.dataset.eventId && !displayEventIds.has(li.dataset.eventId)) {
                  li.remove();
              }
          });

          // 2. 新しいイベントを追加 (順序を保つためreverseしてprepend)
          // events は新しい順 (checkAndUpdateでreverse済み) なので、
          // slice(0, N) も新しい順 [New, Old1, Old2]
          // ループを逆順 [Old2, Old1, New] にして prepend すれば、リスト上は [New, Old1, Old2] になる
          displayEvents.slice().reverse().forEach(event => {
              const eventId = event.time_absolute_iso;
              let li = list.querySelector(`li[data-event-id="${eventId}"]`);

              if (!li) {
                  const time = event.time_date.toLocaleTimeString('ja-JP', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
                  li = document.createElement('li');
                  li.className = 'event-item flash-highlight'; // ★強調クラス
                  li.dataset.eventId = eventId;
                  li.innerHTML = `
                      <div class="event-title">${event.event_title}</div>
                      <div class="event-time">${time} 発生</div>
                  `;
                  list.prepend(li);
                  
                  // アニメーション終了後にクラス削除
                  setTimeout(() => li.classList.remove('flash-highlight'), 2000);
              } else {
                  // 既存なら順序確保のため再配置（見た目変わらず）
                  list.prepend(li);
              }
          });
      }

      // --- データロードとメインループ ---
      
      function initTimeRangeSelector() {
          const select = document.getElementById('time-range-selector');
          select.innerHTML = '';
          
          TIME_RANGE_OPTIONS.forEach(opt => {
              const option = document.createElement('option');
              option.value = opt.value;
              option.textContent = opt.label;
              if (opt.value === currentHistoryMinutes) option.selected = true;
              select.appendChild(option);
          });
          
          select.addEventListener('change', (e) => {
              currentHistoryMinutes = parseInt(e.target.value, 10);
              updateChartData(pricesSchedule); 
          });
      }

      function loadActiveStocks(allStockNames) {
          const stored = localStorage.getItem(LOCAL_STORAGE_KEY);
          if (stored) {
              try {
                  const arr = JSON.parse(stored);
                  if (Array.isArray(arr)) {
                      ACTIVE_STOCKS = new Set(arr);
                      return;
                  }
              } catch (e) { console.error(e); }
          }
          allStockNames.forEach(n => ACTIVE_STOCKS.add(n));
      }

      function saveActiveStocks(set) {
          try {
              localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(Array.from(set)));
          } catch(e) {}
      }

      async function loadSchedule() {
          const loadingMsg = document.getElementById('loading-message');
          try {
              const res = await fetch(JSON_FILE_URL);
              if (!res.ok) throw new Error(res.statusText);
              const data = await res.json();

              if (!data || !data[0] || !data[0].prices_schedule) throw new Error("Invalid JSON format");

              pricesSchedule = data[0].prices_schedule;
              eventsSchedule = data[0].events_schedule;

              [pricesSchedule, eventsSchedule].forEach(arr => {
                  arr.forEach(d => d.time_date = new Date(d.time_absolute_iso));
                  arr.sort((a, b) => a.time_date - b.time_date);
              });

              if (loadingMsg) loadingMsg.remove();
              
              const allNames = pricesSchedule.length > 0 ? pricesSchedule[0].prices.map(p => p.name) : [];
              
              loadActiveStocks(allNames);
              initTimeRangeSelector();
              
              checkAndUpdate();
              setInterval(checkAndUpdate, UPDATE_INTERVAL);

          } catch (e) {
              if (loadingMsg) {
                  loadingMsg.textContent = "データ読み込みエラー";
                  loadingMsg.classList.add("text-red");
              }
              console.error(e);
          }
      }

      function checkAndUpdate() {
          if (pricesSchedule.length === 0) return;
          const now = new Date();
          
          let latestPriceData = null;
          let previousPriceData = null;
          
          for (let i = 0; i < pricesSchedule.length; i++) {
              const entry = pricesSchedule[i];
              if (entry.time_date <= now) {
                  previousPriceData = latestPriceData; 
                  latestPriceData = entry.prices;
              } else {
                  break;
              }
          }

          const recentEvents = eventsSchedule.filter(e => e.time_date <= now).reverse();

          if (latestPriceData) {
              updateDisplay(latestPriceData, previousPriceData, recentEvents);
              updateChartData(pricesSchedule);
          } else {
              const loadingMsg = document.getElementById('loading-message');
              if(loadingMsg) {
                  loadingMsg.style.display = 'flex';
                  loadingMsg.textContent = "ゲーム開始前です";
              }
          }
      }

      // スタート
      loadSchedule();

    })();
  </script>
</body>
</html>
