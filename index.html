<!DOCTYPE html>
<html>
<head>
  <base target="_top">
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!-- Chart.jsライブラリのインポート -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  <!-- 時刻スケール用アダプターの追加 -->
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
  
  <!-- ★★★ 修正点：Tailwind CDNを削除し、インラインスタイルに置き換える ★★★ -->
  <!-- <script src="https://cdn.tailwindcss.com"></script> を削除 -->
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
  <title>ゲーム株価ボード</title>
  <style>
    /* TailwindのCDNを使用しないため、主要なスタイルを手動で記述します */
    body { font-family: 'Inter', sans-serif; background-color: #f0f4f8; margin: 0; padding: 0;}
    .card { 
        box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06); 
        border-radius: 0.5rem; /* rounded-xl */
        transition: transform 0.2s;
    }
    .card:hover {
        transform: translateY(-2px);
    }
    /* レイアウトの基本 */
    .max-w-6xl { max-width: 1152px; }
    .mx-auto { margin-left: auto; margin-right: auto; }
    .p-6 { padding: 1.5rem; }
    .mb-8 { margin-bottom: 2rem; }
    .text-center { text-align: center; }
    .font-extrabold { font-weight: 800; }
    .text-3xl { font-size: 1.875rem; line-height: 2.25rem; }
    .text-indigo-700 { color: rgb(67, 56, 202); }

    /* Flex/Gridレイアウト */
    .grid { display: grid; }
    .grid-cols-1 { grid-template-columns: repeat(1, minmax(0, 1fr)); }
    .lg\\:grid-cols-3 { grid-template-columns: repeat(3, minmax(0, 1fr)); }
    .gap-6 { gap: 1.5rem; }
    .space-y-4 > * + * { margin-top: 1rem; }
    .lg\\:col-span-1 { grid-column: span 1 / span 1; }
    .lg\\:col-span-2 { grid-column: span 2 / span 2; }
    
    /* 価格表示カードの基本 */
    .bg-white { background-color: #fff; }
    .border { border: 1px solid #e5e7eb; }
    .hover\\:border-indigo-400:hover { border-color: rgb(129, 140, 248); }
    .text-xl { font-size: 1.25rem; line-height: 1.75rem; }
    .text-gray-800 { color: #1f2937; }
    .mb-3 { margin-bottom: 0.75rem; }
    .pb-2 { padding-bottom: 0.5rem; }
    .flex { display: flex; }
    .items-end { align-items: flex-end; }
    .justify-between { justify-content: space-between; }
    .text-4xl { font-size: 2.25rem; line-height: 2.5rem; }
    .text-indigo-600 { color: rgb(79, 70, 229); }
    .text-right { text-align: right; }
    .text-lg { font-size: 1.125rem; line-height: 1.75rem; }
    .text-sm { font-size: 0.875rem; line-height: 1.25rem; }
    .text-green-600 { color: rgb(5, 150, 105); }
    .text-red-600 { color: rgb(220, 38, 38); }
    
    /* その他のスタイル */
    .border-b { border-bottom-width: 1px; }
    .pl-3 { padding-left: 0.75rem; }
    .border-l-4 { border-left-width: 4px; }
    .border-indigo-400 { border-color: rgb(129, 140, 248); }
    .text-gray-700 { color: #374151; }
    .text-gray-500 { color: #6b7280; }
    .font-semibold { font-weight: 600; }
  </style>
</head>
<body class="p-4 sm:p-8">
  <div class="max-w-6xl mx-auto">
    <header class="text-center mb-8">
      <h1 class="text-3xl font-extrabold text-indigo-700 mb-2">ゲーム内株価一覧</h1>
      <p class="text-sm text-gray-500">
        最終読み込み時刻: <span id="last-updated" class="font-medium">--</span>
      </p>
    </header>
    
    <!-- 1. 全銘柄の統合株価グラフエリア -->
    <div class="card bg-white p-6 rounded-xl border border-gray-200 shadow-xl mb-8">
        <h2 class="text-xl font-bold text-gray-800 mb-2 border-b pb-2">直近10分間の株価推移（全銘柄）</h2>
        
        <div class="chart-container-wrapper">
            <!-- グラフ本体 (左側) -->
            <div id="chart-container-wrapper" class="combined-chart-area">
                <canvas id="combined-chart"></canvas>
            </div>
            
            <!-- 凡例とチェックボックス (右側) -->
            <div id="chart-legend-wrapper" class="chart-legend-wrapper">
                <h3 class="text-sm font-semibold mb-2 text-gray-700">表示銘柄の選択</h3>
                <div id="chart-legend" class="flex flex-col space-y-1">
                    <!-- 凡例がここに描画されます -->
                </div>
            </div>
        </div>
    </div>
    
    <div class="grid grid-cols-1 lg:grid-cols-3 gap-6 mb-8">
      <!-- 2. 直近イベント履歴エリア -->
      <div id="event-history" class="lg:col-span-1 card bg-white p-6 rounded-xl border border-gray-200">
        <h2 class="text-xl font-bold text-gray-800 mb-3 border-b pb-2">直近のイベント履歴 (3件)</h2>
        <ul id="event-list" class="space-y-3 text-sm">
          <!-- イベントがここに挿入されます -->
        </ul>
      </div>

      <!-- 3. 株価表示エリア (銘柄別カード) -->
      <div class="lg:col-span-2 space-y-4">
        <h2 class="text-xl font-bold text-gray-800 mb-3 border-b pb-2">全銘柄の現在価格と変動</h2>
        <!-- ★★★ 修正点2: グリッドコンテナの余白を制御 ★★★ -->
        <div id="price-board" class="grid grid-cols-1 md:grid-cols-2 gap-4">
          <div id="loading" class="col-span-1 md:col-span-2 text-center text-gray-500 py-10">
            データを読み込み中...
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // IIFEで全体をラッピングし、スコープを隔離
    (function() {
      
      const UPDATE_INTERVAL = 5000; // 5秒ごとにチェック (ミリ秒)
      const HISTORY_MINUTES = 10; // グラフ表示の履歴期間 (N分間)
      const EVENT_HISTORY_COUNT = 3; // イベント履歴の表示件数 (n件)
      const LOCAL_STORAGE_KEY = 'active_stocks'; // LocalStorageキー

      let pricesSchedule = []; 
      let eventsSchedule = []; 
      let ACTIVE_STOCKS = new Set(); // 表示する銘柄を管理するSet
      let stockChart = null; // Chart.jsインスタンスを格納
      
      // 8銘柄の固有色を定義 (Chart.js対応)
      const STOCK_COLORS = {
          "金融": "rgb(59, 130, 246)", // blue-500
          "ヘルスケア": "rgb(16, 185, 129)", // emerald-500
          "情報・通信": "rgb(239, 68, 68)", // red-500
          "インフラ・公共事業": "rgb(245, 158, 11)", // amber-500
          "不動産": "rgb(99, 102, 241)", // indigo-500
          "生活必需品": "rgb(132, 204, 22)", // lime-500
          "化学・素材": "rgb(249, 115, 22)", // orange-500
          "エネルギー": "rgb(168, 85, 247)" // violet-500
      };
      
      // --- デモデータ: 現在時刻より5分前を基準に設定 ---
      const BASE_TIME = new Date(new Date().getTime() - (5 * 60 * 1000));
      
      // デモスケジュール
      pricesSchedule = [
          { "time_absolute_iso": new Date(BASE_TIME.getTime()).toISOString(), "prices": [{"name": "金融", "price": 1000}, {"name": "ヘルスケア", "price": 2500}, {"name": "情報・通信", "price": 850}, {"name": "インフラ・公共事業", "price": 1200}, {"name": "不動産", "price": 400}, {"name": "生活必需品", "price": 900}, {"name": "化学・素材", "price": 3200}, {"name": "エネルギー", "price": 1500}] },
          { "time_absolute_iso": new Date(BASE_TIME.getTime() + (90 * 1000)).toISOString(), "prices": [{"name": "金融", "price": 1050}, {"name": "ヘルスケア", "price": 2500}, {"name": "情報・通信", "price": 850}, {"name": "インフラ・公共事業", "price": 1200}, {"name": "不動産", "price": 350}, {"name": "生活必需品", "price": 900}, {"name": "化学・素材", "price": 3150}, {"name": "エネルギー", "price": 1500}] },
          { "time_absolute_iso": new Date(BASE_TIME.getTime() + (180 * 1000)).toISOString(), "prices": [{"name": "金融", "price": 1050}, {"name": "ヘルスケア", "price": 2500}, {"name": "情報・通信", "price": 1000}, {"name": "インフラ・公共事業", "price": 1200}, {"name": "不動産", "price": 350}, {"name": "生活必需品", "price": 900}, {"name": "化学・素材", "price": 3150}, {"name": "エネルギー", "price": 1500}] },
          { "time_absolute_iso": new Date(BASE_TIME.getTime() + (330 * 1000)).toISOString(), "prices": [{"name": "金融", "price": 1050}, {"name": "ヘルスケア", "price": 2550}, {"name": "情報・通信", "price": 950}, {"name": "インフラ・公共事業", "price": 1200}, {"name": "不動産", "price": 350}, {"name": "生活必需品", "price": 950}, {"name": "化学・素材", "price": 2800}, {"name": "エネルギー", "price": 1400}] },
          { "time_absolute_iso": new Date(BASE_TIME.getTime() + (480 * 1000)).toISOString(), "prices": [{"name": "金融", "price": 1100}, {"name": "ヘルスケア", "price": 2600}, {"name": "情報・通信", "price": 1100}, {"name": "インフラ・公共事業", "price": 1250}, {"name": "不動産", "price": 450}, {"name": "生活必需品", "price": 1000}, {"name": "化学・素材", "price": 2900}, {"name": "エネルギー", "price": 1500}] },
          { "time_absolute_iso": new Date(BASE_TIME.getTime() + (630 * 1000)).toISOString(), "prices": [{"name": "金融", "price": 1200}, {"name": "ヘルスケア", "price": 2400}, {"name": "情報・通信", "price": 1200}, {"name": "インフラ・公共事業", "price": 1300}, {"name": "不動産", "price": 500}, {"name": "生活必需品", "price": 950}, {"name": "化学・素材", "price": 3000}, {"name": "エネルギー", "price": 1600}]}
      ];

      eventsSchedule = [
          {"time_absolute_iso": new Date(BASE_TIME.getTime()).toISOString(), "event_title": "ゲーム開始: 初期価格設定"},
          {"time_absolute_iso": new Date(BASE_TIME.getTime() + (90 * 1000)).toISOString(), "event_title": "中央銀行が金利を緊急引き上げ（イベント1）"},
          {"time_absolute_iso": new Date(BASE_TIME.getTime() + (180 * 1000)).toISOString(), "event_title": "革新的なAIチップが発表される（イベント6）"},
          {"time_absolute_iso": new Date(BASE_TIME.getTime() + (330 * 1000)).toISOString(), "event_title": "世界的な景気後退入り（イベント2）"},
          {"time_absolute_iso": new Date(BASE_TIME.getTime() + (480 * 1000)).toISOString(), "event_title": "重要鉱物（レアメタル）の国内資源開発成功（イベント43）"},
          {"time_absolute_iso": new Date(BASE_TIME.getTime() + (630 * 1000)).toISOString(), "event_title": "次のイベント予定: 新技術の発表"}
      ];

      // --- UTILITY FUNCTIONS ---
      
      /**
       * 価格に基づいて、Y軸の最小値と最大値をキリの良い数字で決定する
       */
      function getYAxisScale(minPrice, maxPrice) {
          const range = maxPrice - minPrice;
          if (range <= 0) { // 価格変動がない場合
              const center = minPrice;
              return { scaleMin: center - 50, scaleMax: center + 50 };
          }
          
          let niceInterval = 1;
          const roughInterval = range / 5; // 約5つの目盛り
          const power = Math.pow(10, Math.floor(Math.log10(roughInterval)));
          
          if (roughInterval > 5 * power) niceInterval = 10 * power;
          else if (roughInterval > 2 * power) niceInterval = 5 * power;
          else niceInterval = 2 * power;
          
          const scaleMin = Math.floor(minPrice / niceInterval) * niceInterval;
          const scaleMax = Math.ceil(maxPrice / niceInterval) * niceInterval;
          return { scaleMin, scaleMax };
      }

      /**
       * Chart.jsインスタンスを初期化または更新する
       */
      function initializeChart(chartData, scaleMin, scaleMax, chartRangeMs) {
          const canvas = document.getElementById('combined-chart');
          const ctx = canvas ? canvas.getContext('2d') : null;
          
          if (!ctx) return;
          
          if (stockChart) {
              // 既にインスタンスが存在する場合はデータを更新
              stockChart.data = chartData;
              stockChart.options.scales.y.min = scaleMin;
              stockChart.options.scales.y.max = scaleMax;
              stockChart.options.scales.x.min = Date.now() - chartRangeMs;
              stockChart.options.scales.x.max = Date.now();
              stockChart.update('none'); // アニメーションなしで更新
              return;
          }

          // 新しいインスタンスの作成
          stockChart = new Chart(ctx, {
              type: 'line',
              data: chartData,
              options: {
                  responsive: true,
                  maintainAspectRatio: false,
                  animation: { duration: 0 },
                  layout: { padding: { top: 10, bottom: 0 } },
                  plugins: {
                      legend: { display: false }, // 凡例はカスタムHTMLで表示
                      tooltip: { mode: 'index', intersect: false }
                  },
                  scales: {
                      x: {
                          type: 'time',
                          time: {
                              unit: 'minute',
                              displayFormats: { minute: 'H:mm' }
                          },
                          min: Date.now() - chartRangeMs, // グラフの左端 (現在時刻 - 10分)
                          max: Date.now(), // グラフの右端 (現在時刻)
                          ticks: { 
                              source: 'auto',
                              autoSkip: true,
                              maxTicksLimit: 5
                          },
                          title: { display: true, text: '時刻' }
                      },
                      y: {
                          min: scaleMin,
                          max: scaleMax,
                          title: { display: true, text: '株価 (¥)' },
                          ticks: {
                              callback: (value) => `¥${value.toLocaleString()}`,
                              maxTicksLimit: 6,
                              precision: 0
                          }
                      }
                  }
              }
          });
          
          // 初回ロード時、凡例のチェック状態を反映
          stockChart.data.datasets.forEach((ds, index) => {
             stockChart.setDatasetVisibility(index, ACTIVE_STOCKS.has(ds.label));
          });
          stockChart.update();
      }

      /**
       * グラフのX軸/Y軸データをChart.js形式に変換し、更新をトリガーする
       */
      function updateChartData() {
          const now = Date.now();
          const historyMs = HISTORY_MINUTES * 60 * 1000;
          const chartStartMs = now - historyMs;

          // 1. フィルタリングされた履歴データを取得
          const filteredHistory = pricesSchedule.filter(entry => 
              entry.time_date.getTime() >= chartStartMs && entry.time_date.getTime() <= now
          );

          if (filteredHistory.length === 0) {
              const container = document.getElementById('chart-container-wrapper');
              if (stockChart) stockChart.destroy();
              container.innerHTML = '<p class="text-center text-gray-500 py-10">表示する履歴データがありません。</p>';
              return;
          }
          
          // 2. 全銘柄の最小・最大価格を特定
          let allPrices = filteredHistory.flatMap(entry => entry.prices.map(p => p.price));
          let minPrice = Math.min(...allPrices);
          let maxPrice = Math.max(...allPrices);
          
          // 3. Y軸スケールをキリの良い数字に設定
          const { scaleMin, scaleMax } = getYAxisScale(minPrice, maxPrice);

          // 4. データセットを構築
          const stockNames = pricesSchedule.length > 0 ? pricesSchedule[0].prices.map(p => p.name) : [];
          const datasets = stockNames.map(name => {
              const dataPoints = filteredHistory.map(entry => {
                  const priceEntry = entry.prices.find(p => p.name === name);
                  return {
                      x: entry.time_date.getTime(), // Chart.jsではミリ秒で渡す
                      y: priceEntry ? priceEntry.price : null 
                  };
              });

              return {
                  label: name,
                  data: dataPoints,
                  borderColor: STOCK_COLORS[name],
                  backgroundColor: STOCK_COLORS[name],
                  borderWidth: 2,
                  pointRadius: 3,
                  fill: false,
                  tension: 0
              };
          });

          const chartData = { datasets };
          initializeChart(chartData, scaleMin, scaleMax, historyMs);
      }

      /**
       * 凡例（レジェンド）を描画する
       */
      function drawLegend(stockNames) {
          const legendContainer = document.getElementById('chart-legend');
          legendContainer.innerHTML = '';
          
          stockNames.forEach(stockName => {
              const color = STOCK_COLORS[stockName] || '#000000';
              const legendItem = document.createElement('label');
              legendItem.className = 'legend-item';
              legendItem.setAttribute('for', `check-${stockName}`);
              
              // チェックボックスとラベルを生成
              legendItem.innerHTML = `
                  <input type="checkbox" id="check-${stockName}" data-stock-name="${stockName}"
                         ${ACTIVE_STOCKS.has(stockName) ? 'checked' : ''}
                         style="accent-color: ${color};"
                         class="mr-2 h-4 w-4 rounded cursor-pointer border-gray-400 focus:ring-indigo-500">
                  <span style="background-color: ${color}; width:10px; height:10px; border-radius:50%; margin-right:4px;"></span>
                  <span class="truncate">${stockName}</span>
              `;
              legendContainer.appendChild(legendItem);
              
              // イベントリスナーの追加
              legendItem.querySelector('input').addEventListener('change', (e) => {
                  const name = e.target.dataset.stockName;
                  if (e.target.checked) {
                      ACTIVE_STOCKS.add(name);
                  } else {
                      ACTIVE_STOCKS.delete(name);
                  }
                  // LocalStorageに保存
                  saveActiveStocks(ACTIVE_STOCKS); 

                  // チェックボックスの状態が変わったら、グラフを再描画
                  if (stockChart) {
                      const datasetIndex = stockChart.data.datasets.findIndex(ds => ds.label === name);
                      if (datasetIndex > -1) {
                          stockChart.setDatasetVisibility(datasetIndex, e.target.checked);
                          stockChart.update();
                      }
                  }
              });
          });
      }

      /**
       * イベント履歴を表示する
       */
      function updateEventHistory(events) {
          const list = document.getElementById('event-list');
          list.innerHTML = ''; // リセット
          
          if (events.length === 0) {
              list.innerHTML = '<li class="text-gray-500">現在、発生済みのイベントはありません。</li>';
              return;
          }
          
          // イベント履歴の表示件数 (EVENT_HISTORY_COUNT) に制限
          events.slice(0, EVENT_HISTORY_COUNT).forEach(event => {
              const time = event.time_date.toLocaleTimeString('ja-JP', { hour: '2-digit', minute: '2-digit' });
              const listItem = document.createElement('li');
              listItem.className = 'border-l-4 border-indigo-400 pl-3 text-gray-700';
              listItem.innerHTML = `
                  <span class="font-semibold">${event.event_title}</span><br>
                  <span class="text-xs text-gray-500">${time} 発生</span>
              `;
              list.appendChild(listItem);
          });
      }
      
      /**
       * 取得したデータに基づいてHTMLを更新する (銘柄カードの描画)
       */
      function updateDisplay(currentPrices, previousPrices, recentEvents) {
        const board = document.getElementById('price-board');
        
        // イベント履歴の更新
        updateEventHistory(recentEvents);

        // 初回表示時の処理
        if (board.children.length === 0 || board.children[0].id === 'loading') { board.innerHTML = ''; }

        currentPrices.forEach(item => {
          const formattedPrice = item.price.toLocaleString();
          const safeName = item.name.replace(/[^a-zA-Z0-9\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF]/g, ''); 
          const priceId = `price-${safeName}`;
          
          let existingElement = document.getElementById(priceId);
          let prevPrice = previousPrices ? previousPrices.find(p => p.name === item.name)?.price : item.price;
          prevPrice = prevPrice || item.price; 
          
          // 増減額と割合の計算
          const changeAmount = item.price - prevPrice;
          const changeRatio = prevPrice > 0 ? (changeAmount / prevPrice) * 100 : 0;
          const sign = changeAmount >= 0 ? '▲' : '▼';
          const colorClass = changeAmount >= 0 ? 'text-green-600' : 'text-red-600';

          if (!existingElement) {
              const newDiv = document.createElement('div');
              newDiv.id = priceId;
              newDiv.className = "card bg-white p-5 rounded-xl border border-gray-200 hover:border-indigo-400 transition duration-150 flex flex-col justify-center";
              newDiv.innerHTML = `
                  <h2 class="text-xl font-semibold text-gray-600 mb-2">${item.name}</h2>
                  <div class="flex items-end justify-between mb-3">
                    <p class="text-4xl font-bold text-indigo-600 price-value">¥ ${formattedPrice}</p>
                    <div class="text-right">
                        <p class="text-lg font-bold ${colorClass}">
                            ${sign} ${changeAmount.toLocaleString()}
                        </p>
                        <p class="text-sm ${colorClass}">
                            (${changeRatio.toFixed(2)}%)
                        </p>
                    </div>
                  </div>
              `;
              board.appendChild(newDiv);

          } else {
              // 既存要素の更新
              const priceSpan = existingElement.querySelector('.price-value');
              const changeAmountElement = existingElement.querySelector('.text-lg');
              const changeRatioElement = existingElement.querySelector('.text-sm');
              
              if (priceSpan.textContent !== `¥ ${formattedPrice}`) {
                  priceSpan.classList.add('animate-pulse-once');
                  priceSpan.textContent = `¥ ${formattedPrice}`;
                  setTimeout(() => priceSpan.classList.remove('animate-pulse-once'), 1000); 
              }
              
              // 変動情報を更新
              [changeAmountElement, changeRatioElement].forEach(el => {
                  el.classList.remove('text-green-600', 'text-red-600');
                  el.classList.add(colorClass);
              });
              changeAmountElement.textContent = `${sign} ${changeAmount.toLocaleString()}`;
              changeRatioElement.textContent = `(${changeRatio.toFixed(2)}%)`;
          }
        });
        
        document.getElementById('last-updated').textContent = new Date().toLocaleTimeString('ja-JP');
      }

      // --- LocalStorage Utility Functions ---
      
      /**
       * LocalStorageからアクティブな銘柄を読み込む
       */
      function loadActiveStocks(allStockNames) {
          const stored = localStorage.getItem(LOCAL_STORAGE_KEY);
          if (stored) {
              try {
                  const storedArray = JSON.parse(stored);
                  if (Array.isArray(storedArray)) {
                      ACTIVE_STOCKS = new Set(storedArray);
                      return;
                  }
              } catch (e) {
                  console.error("Failed to parse stored active stocks:", e);
              }
          }
          
          // 初回またはデータ不正の場合、全てアクティブにする
          allStockNames.forEach(name => ACTIVE_STOCKS.add(name));
      }

      /**
       * LocalStorageにアクティブな銘柄を保存する
       */
      function saveActiveStocks(activeSet) {
          try {
              localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(Array.from(activeSet)));
          } catch (e) {
              console.error("Failed to save active stocks:", e);
          }
      }

      /**
       * デモデータをロードし、初期化する (メイン)
       */
      function loadSchedule() {
        const loadingElement = document.getElementById('loading');
        
        // ISO文字列をDateオブジェクトに変換し、ソートする
        [pricesSchedule, eventsSchedule].forEach(schedule => {
            schedule.forEach(entry => {
                entry.time_date = new Date(entry.time_absolute_iso);
            });
            schedule.sort((a, b) => a.time_date.getTime() - b.time_date.getTime()); 
        });
        
        // ロード完了
        if (loadingElement) loadingElement.remove();
        
        const allStockNames = pricesSchedule.length > 0 ? pricesSchedule[0].prices.map(p => p.name) : [];
        
        // 状態を読み込み、凡例を描画
        loadActiveStocks(allStockNames); 
        drawLegend(allStockNames); 

        checkAndUpdate();
        setInterval(checkAndUpdate, UPDATE_INTERVAL);
      }


      /**
       * 現在時刻に基づいて表示を更新するメインロジック (CORE)
       */
      function checkAndUpdate() {
        if (pricesSchedule.length === 0) return; 
        
        const now = new Date();
        
        let latestPriceData = null;
        let previousPriceData = null;
        let recentPriceHistory = [];
        
        // 価格スケジュール全体をループし、過去のデータを保持
        const historyStartMs = now.getTime() - (HISTORY_MINUTES * 60 * 1000);

        for (let i = 0; i < pricesSchedule.length; i++) {
          const priceEntry = pricesSchedule[i];
          const timeMs = priceEntry.time_date.getTime();
          
          // 直近N分間の履歴抽出
          if (timeMs >= historyStartMs && timeMs <= now.getTime()) {
              recentPriceHistory.push(priceEntry);
          }

          // 最新の価格特定
          if (timeMs <= now.getTime()) {
            previousPriceData = latestPriceData;
            latestPriceData = priceEntry.prices;
          } else {
            break; 
          }
        }

        // 2. イベント履歴の特定
        const recentEvents = [];
        for (let i = eventsSchedule.length - 1; i >= 0; i--) {
            const eventEntry = eventsSchedule[i];
            if (eventEntry.time_date.getTime() <= now.getTime()) {
                recentEvents.push(eventEntry);
                if (recentEvents.length >= EVENT_HISTORY_COUNT) break;
            }
        }
        
        // 4. 画面表示の更新
        if (latestPriceData) {
            updateDisplay(latestPriceData, previousPriceData, recentEvents);
            // 統合グラフの描画
            updateChartData(); // Chart.jsの更新関数を呼び出す
        } else {
            // ゲーム開始前
            document.getElementById('price-board').innerHTML = '<div class="col-span-1 md:col-span-2 text-center text-gray-500 py-10">ゲーム開始時刻までお待ちください。</div>';
            updateEventHistory([]);
        }
      }
      
      // スケジュールをロードして処理を開始
      loadSchedule();
    })();
  </script>
</body>
</html>
